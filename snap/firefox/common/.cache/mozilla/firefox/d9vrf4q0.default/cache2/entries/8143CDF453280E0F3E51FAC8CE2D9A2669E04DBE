WEBVTT


00:00:00.000 --> 00:00:02.899
Let's talk about this problem. We are given

00:00:02.899 --> 00:00:04.900
a number n. Our task is

00:00:04.900 --> 00:00:06.500
to find out whether the given

00:00:06.500 --> 00:00:08.698
number is a palindrome number or not.

00:00:09.000 --> 00:00:11.698
The given number is greater than or equal to 0.

00:00:12.198 --> 00:00:14.800
A number is called palindrome if

00:00:14.800 --> 00:00:16.500
it's reverse, is same as a

00:00:16.500 --> 00:00:18.899
number. So if you read the number from left to

00:00:18.899 --> 00:00:20.899
right, or you read from right to left, you get

00:00:20.899 --> 00:00:22.800
the same number. Then this number is

00:00:22.800 --> 00:00:24.899
called palindrome number, and if it's

00:00:24.899 --> 00:00:26.699
not true, then it's not a palindrome

00:00:26.699 --> 00:00:28.500
number. For example,

00:00:28.600 --> 00:00:29.800
78987

00:00:30.000 --> 00:00:32.899
If you read it from left to right, you get the same you read

00:00:32.899 --> 00:00:34.798
from right to left, you get the same. It's a

00:00:34.798 --> 00:00:36.899
palindrome number 8668

00:00:36.899 --> 00:00:38.899
again a palindrome number. If you

00:00:38.899 --> 00:00:40.899
read from right side, 8668

00:00:42.200 --> 00:00:44.899
8, a single digit number is always a palindrome. Because if you

00:00:44.899 --> 00:00:46.899
read it from left to right, or right to left, you will get a

00:00:46.899 --> 00:00:48.798
single digit only. Now,

00:00:48.798 --> 00:00:50.798
this number is not a palindrome because from

00:00:50.798 --> 00:00:52.899
right to left, I will get 12, right? From

00:00:52.899 --> 00:00:54.500
left to right and getting 21.

00:00:55.000 --> 00:00:57.798
This number is also not palindrome because if I read from right to

00:00:57.798 --> 00:00:59.700
left, I will get 763.

00:01:00.000 --> 00:01:02.798
Is not same as 367. Now, please

00:01:02.798 --> 00:01:04.700
pause this video and try to write down a

00:01:04.700 --> 00:01:06.900
function that takes a number as

00:01:06.900 --> 00:01:08.599
an argument and returns a

00:01:08.599 --> 00:01:10.700
Boolean value, which is

00:01:10.799 --> 00:01:12.900
true if they were given input. Number is a

00:01:12.900 --> 00:01:14.700
palindrome number. Otherwise,

00:01:14.700 --> 00:01:16.700
false. Let us now, talk

00:01:16.700 --> 00:01:18.900
about the idea to solve the problem. The

00:01:18.900 --> 00:01:20.799
idea is simple. We find the

00:01:20.799 --> 00:01:22.599
reverse of the given number, then we

00:01:22.599 --> 00:01:24.799
check if the reverse of the given number, is

00:01:24.799 --> 00:01:26.900
same as given number. If the reverse is

00:01:26.900 --> 00:01:28.799
saved, then we say it's a palindrome number.

00:01:28.799 --> 00:01:29.599
Otherwise, not,

00:01:29.900 --> 00:01:31.900
for example, 367 if you find

00:01:31.900 --> 00:01:33.000
reverse of it, you will get

00:01:33.000 --> 00:01:35.799
763, which is not same as 367. So,

00:01:35.799 --> 00:01:36.700
will return false

00:01:37.599 --> 00:01:39.900
363. If you find reverse of it, you

00:01:39.900 --> 00:01:41.900
will get 363 and at same as

00:01:41.900 --> 00:01:43.799
the original number. So, you will return true.

00:01:44.989 --> 00:01:46.900
Now, the question arises, how do we find reverse of

00:01:46.900 --> 00:01:48.900
a given number to find

00:01:48.900 --> 00:01:50.799
reverse of a given number, we need to

00:01:50.799 --> 00:01:52.599
traverse the digits from last to

00:01:52.599 --> 00:01:54.900
first and traversal of digits from last

00:01:54.900 --> 00:01:56.599
to First is really easy.

00:01:57.000 --> 00:01:59.799
We can find last digit of a number by using the

00:02:00.000 --> 00:02:02.799
% operator. If I do X %10, I will

00:02:02.799 --> 00:02:04.799
get the last digit of X because

00:02:04.799 --> 00:02:06.900
this percent operator gives you remainder

00:02:06.900 --> 00:02:08.900
after division with 10. So if I

00:02:08.900 --> 00:02:10.900
do x 367 % 10,

00:02:10.900 --> 00:02:12.699
then I will get 7 and then

00:02:13.199 --> 00:02:15.900
to remove 7 from our original number so that we

00:02:15.900 --> 00:02:17.800
can get 6 next time, we do

00:02:17.800 --> 00:02:19.800
x equal to x by 10. If I

00:02:19.800 --> 00:02:21.300
do x equal to x by 10.

00:02:21.800 --> 00:02:23.800
I get rid of the last digit. So, next

00:02:23.800 --> 00:02:25.800
time, when I do x % 10, I

00:02:25.800 --> 00:02:27.900
will get second last digit. Right? That's

00:02:27.900 --> 00:02:29.800
the idea we follow to get,

00:02:29.900 --> 00:02:31.598
digits from right to left

00:02:31.598 --> 00:02:33.900
side. In every iteration, we are going to

00:02:33.900 --> 00:02:35.900
get the last digit and then we are going to do

00:02:35.900 --> 00:02:37.800
x equal to x by 10. So,

00:02:37.800 --> 00:02:39.800
this is how I can traverse through all the

00:02:39.800 --> 00:02:41.900
results from 7 to 3.

00:02:42.300 --> 00:02:44.900
Now I can traverse all the results, how do I

00:02:44.900 --> 00:02:46.400
find the reverse of a given number?

00:02:46.900 --> 00:02:48.500
I'll initialize the reverse as

00:02:48.500 --> 00:02:50.900
0 and in every iteration I will do

00:02:50.900 --> 00:02:52.800
reverse equal to the reverse into 10

00:02:52.800 --> 00:02:54.800
plus 7, whatever. The last

00:02:54.800 --> 00:02:56.800
digit is, for example, the current last

00:02:56.800 --> 00:02:58.500
digit 7 and then I will add 7

00:02:58.900 --> 00:02:59.800
this way. I will

00:03:00.000 --> 00:03:02.800
get the reverse first as seven and in the

00:03:02.800 --> 00:03:04.699
next iteration I will get 7

00:03:04.699 --> 00:03:06.500
into 10 which is 70

00:03:06.598 --> 00:03:08.598
plus 6. The current last

00:03:08.598 --> 00:03:10.800
digits. I'll get 76. In the

00:03:10.800 --> 00:03:12.598
third iteration, I will do

00:03:12.598 --> 00:03:14.699
76 into 10

00:03:14.699 --> 00:03:16.300
760 plus 3,

00:03:16.300 --> 00:03:18.900
763. So, I'll get the reverse of the

00:03:18.900 --> 00:03:20.800
number. Let's do one more example

00:03:21.400 --> 00:03:23.699
here. My last digit is 3 and

00:03:23.699 --> 00:03:25.699
my result is initializes 0,

00:03:25.800 --> 00:03:27.800
so we will do, reverse equal to

00:03:27.800 --> 00:03:29.800
reverse into 10, plus 3 will get 0.

00:03:29.900 --> 00:03:31.900
Plus 3, 3. Then

00:03:31.900 --> 00:03:33.699
we will come to the second last digit 6

00:03:33.699 --> 00:03:35.800
and we'll do 3 into 10, 30 plus

00:03:35.800 --> 00:03:37.900
6, 36. Then, we'll come to

00:03:37.900 --> 00:03:39.598
the first digit. We will go through

00:03:39.598 --> 00:03:41.900
36 into 10 plus 3, which

00:03:41.900 --> 00:03:43.800
is 363. So, we'll get the

00:03:43.800 --> 00:03:45.699
reverse as this and at the end, we'll

00:03:45.699 --> 00:03:47.699
simply check. If this reverse is same as this or

00:03:47.699 --> 00:03:49.800
not. In this case, it's not same. In

00:03:49.800 --> 00:03:51.800
this case, it is same. Now, please

00:03:51.800 --> 00:03:53.900
pause this video and try to implement

00:03:53.900 --> 00:03:55.800
this approach yourself. Let's now

00:03:55.800 --> 00:03:57.699
take a look at the implementation. This

00:03:57.699 --> 00:03:59.800
implementation is almost same.

00:04:00.000 --> 00:04:02.900
C++ and Java. In Java, we just need

00:04:02.900 --> 00:04:04.699
to replace this bool with Boolean.

00:04:05.300 --> 00:04:07.598
This function, takes an integer n as an

00:04:07.598 --> 00:04:09.699
argument. It initializes

00:04:09.699 --> 00:04:11.900
reverse of this number is 0 and

00:04:11.900 --> 00:04:13.400
at the end, it simply

00:04:13.400 --> 00:04:15.500
returns, return value of this

00:04:15.500 --> 00:04:17.800
expression. And what is this expression? This

00:04:17.800 --> 00:04:19.699
expression is reverse equal to

00:04:19.699 --> 00:04:21.500
equal to n comparison of reverse.

00:04:21.500 --> 00:04:23.899
And if they are same, then this expression is

00:04:23.899 --> 00:04:25.600
going to return true otherwise it's going to

00:04:25.600 --> 00:04:27.800
return false. So we

00:04:27.899 --> 00:04:29.699
have reverse here and that the end we

00:04:29.899 --> 00:04:31.800
Checking the reverse and then in the middle, we are

00:04:31.800 --> 00:04:33.500
simply computing the reverse of given

00:04:33.500 --> 00:04:35.899
number. Now, how do we compute the given reverse

00:04:35.899 --> 00:04:37.899
of given number? For that we have

00:04:37.899 --> 00:04:39.699
already discussed the logic. We are going to

00:04:39.699 --> 00:04:41.899
take the last digits, one by one. And then

00:04:41.899 --> 00:04:43.600
we are going to remove the last digit

00:04:43.899 --> 00:04:45.699
and then we are going to update the reverse

00:04:46.300 --> 00:04:48.899
but we need our original number at the end,

00:04:49.000 --> 00:04:51.800
right? So we can't remove the last digit of given number.

00:04:52.399 --> 00:04:54.699
Due to this reason, we create another number

00:04:54.699 --> 00:04:56.600
temp. In this temp, we

00:04:56.600 --> 00:04:58.899
first store n and then we

00:04:59.000 --> 00:04:59.800
get the

00:04:59.899 --> 00:05:01.800
last digit of temp and then we'll remove the

00:05:01.800 --> 00:05:03.600
last digit of temp, so that when we

00:05:03.800 --> 00:05:05.500
try to get the last digit next time,

00:05:06.100 --> 00:05:08.500
we have no previous last digits,

00:05:08.500 --> 00:05:10.800
right? So, let us see the working of this function. With

00:05:10.800 --> 00:05:12.800
this example, this is not a palindrome

00:05:12.800 --> 00:05:14.699
number at the end. You will get the

00:05:14.699 --> 00:05:16.899
reverse as 3554 and

00:05:16.899 --> 00:05:18.699
they are not same. So this expression will

00:05:18.699 --> 00:05:20.899
return false. Let's see, how are we getting

00:05:20.899 --> 00:05:22.000
this reverse number?

00:05:22.500 --> 00:05:24.800
So we have initialized reverse as

00:05:24.800 --> 00:05:26.800
0 and we have  re-initialized them best the

00:05:26.800 --> 00:05:28.699
same number. Now, we are

00:05:29.100 --> 00:05:29.699
removing

00:05:29.899 --> 00:05:31.899
last digits, one by one from the temp and we are

00:05:31.899 --> 00:05:33.800
updating the temp and we are also updating the

00:05:33.800 --> 00:05:35.800
reverse. So first thing we do is we

00:05:35.800 --> 00:05:37.800
get the last digit in a variable ld.

00:05:38.100 --> 00:05:40.899
So, ld is last digit of this number three, and then

00:05:40.899 --> 00:05:42.600
we update reverse. Reverse was

00:05:42.600 --> 00:05:44.899
initially 0. Now, it becomes 0 into 10

00:05:44.899 --> 00:05:46.899
plus 3, which is 3. And then

00:05:46.899 --> 00:05:48.899
we update the temp, temp equal to 10

00:05:48.899 --> 00:05:50.500
by 10. So large as it

00:05:50.500 --> 00:05:52.800
removes. Now our temp becomes

00:05:52.899 --> 00:05:54.899
455. In the second

00:05:54.899 --> 00:05:56.899
iteration we do the same thing. Our

00:05:56.899 --> 00:05:58.500
temp is now 455

00:05:59.000 --> 00:05:59.800
we get the

00:05:59.899 --> 00:06:01.899
last digit by doing temp%

00:06:01.899 --> 00:06:03.800
10. We get the last digit is

00:06:03.800 --> 00:06:05.800
5 then we update the reverses

00:06:05.800 --> 00:06:07.500
3 into 10 plus 5

00:06:07.500 --> 00:06:09.800
35 and then we remove the last digit

00:06:09.800 --> 00:06:11.899
by doing this operation. So what temp

00:06:11.899 --> 00:06:13.800
now becomes 45. In the

00:06:13.800 --> 00:06:15.699
third iteration, we get the

00:06:15.699 --> 00:06:17.600
last digit of remaining number which is

00:06:17.600 --> 00:06:19.699
45 right doing temp

00:06:19.699 --> 00:06:21.899
percent 10 will give us last digit

00:06:21.899 --> 00:06:23.899
is 5 and now we update,

00:06:23.899 --> 00:06:25.199
the reverse, reverse is going to be

00:06:25.199 --> 00:06:27.600
35 into 10 plus 5 which is

00:06:27.600 --> 00:06:29.699
355. And then

00:06:29.800 --> 00:06:31.899
We update the temp. So

00:06:31.899 --> 00:06:33.699
update the time we do, temp equal to temp

00:06:33.699 --> 00:06:35.600
by 10, you simply remove the last digit,

00:06:35.600 --> 00:06:37.800
right? So we get temp is 4

00:06:38.300 --> 00:06:40.600
now we only one digit. So one more iteration,

00:06:40.899 --> 00:06:42.600
now we get the last digit

00:06:42.600 --> 00:06:44.899
as 4, by this operation

00:06:45.399 --> 00:06:47.800
and then we get the reverse as 3 5

00:06:47.800 --> 00:06:48.699
5 into 10

00:06:48.699 --> 00:06:50.800
3550 plus 4, 3

00:06:50.800 --> 00:06:52.800
5 5 4 and then we do

00:06:52.800 --> 00:06:54.899
temp equal to 10 by 10. So 4

00:06:54.899 --> 00:06:56.800
by 10 now becomes 0.

00:06:56.800 --> 00:06:58.899
And when temp become 0 we come out of this

00:06:58.899 --> 00:06:59.699
Loop and

00:07:00.000 --> 00:07:02.500
Come out of this loop. We have reverse and we have our

00:07:02.500 --> 00:07:04.600
original number in N is simply

00:07:04.600 --> 00:07:06.399
compare these two and we return

00:07:06.399 --> 00:07:08.500
false. Let us now, talk about time

00:07:08.500 --> 00:07:10.600
complexity of the solution. We are

00:07:10.600 --> 00:07:12.699
simply traversing through all the digits of a

00:07:12.699 --> 00:07:14.800
given number. So we can say time

00:07:14.800 --> 00:07:16.699
complexity is Theta of d,

00:07:16.699 --> 00:07:18.899
where d is the number of digits in our

00:07:18.899 --> 00:07:19.699
input number,´Ï§7ž      h–Šh–ŠHnÉ¯h–Š   ›    O^partitionKey=%28https%2Cgeeksforgeeks.org%29,a,:https://cdnvideos.geeksforgeeks.org/subtitles/c8fb1d801b68744961b9185ee13857ebgfg-Palndrome%20Numbers.vtt strongly-framed 1 security-info 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 request-method GET response-head HTTP/2 200 
x-guploader-uploadid: AKDAyItPgJ2K1tdgUtzfU2S12AmO7ZhYulDad3b_1Z4eOJO59VfjX-iw606xuKyhWmmy9N2apwMb8g
x-goog-generation: 1724746212703870
x-goog-metageneration: 1
x-goog-stored-content-encoding: identity
x-goog-stored-content-length: 13640
x-goog-meta-x-goog-source-etag: "44d1dc122e03f6b9e2dc9010fc07e50e"
x-goog-hash: md5=RNHcEi4D9rni3JAQ/AflDg==
x-goog-storage-class: STANDARD
accept-ranges: bytes
content-length: 13640
server: Google-Edge-Cache
x-request-id: 3dd7fb4a-160f-4dd8-8331-eca5901a7363
x-xss-protection: 0
x-frame-options: SAMEORIGIN
x-content-type-options: nosniff
date: Wed, 16 Apr 2025 10:00:59 GMT
age: 8394415
last-modified: Tue, 27 Aug 2024 08:10:12 GMT
etag: "44d1dc122e03f6b9e2dc9010fc07e50e"
content-type: binary/octet-stream
cdn_cache_status: maa;hit
cache-control: public,max-age=86400
access-control-allow-origin: https://aa.geeksforgeeks.org
X-Firefox-Spdy: h2
 original-response-headers x-guploader-uploadid: AKDAyItPgJ2K1tdgUtzfU2S12AmO7ZhYulDad3b_1Z4eOJO59VfjX-iw606xuKyhWmmy9N2apwMb8g
x-goog-generation: 1724746212703870
x-goog-metageneration: 1
x-goog-stored-content-encoding: identity
x-goog-stored-content-length: 13640
x-goog-meta-x-goog-source-etag: "44d1dc122e03f6b9e2dc9010fc07e50e"
x-goog-hash: md5=RNHcEi4D9rni3JAQ/AflDg==
x-goog-storage-class: STANDARD
accept-ranges: bytes
content-length: 13640
server: Google-Edge-Cache
x-request-id: 3dd7fb4a-160f-4dd8-8331-eca5901a7363
x-xss-protection: 0
x-frame-options: SAMEORIGIN
x-content-type-options: nosniff
date: Wed, 16 Apr 2025 10:00:59 GMT
age: 8394415
last-modified: Tue, 27 Aug 2024 08:10:12 GMT
etag: "44d1dc122e03f6b9e2dc9010fc07e50e"
content-type: binary/octet-stream
cdn_cache_status: maa;hit
cache-control: public,max-age=86400
access-control-allow-origin: https://aa.geeksforgeeks.org
X-Firefox-Spdy: h2
 ctid 1 net-response-time-onstart 40 net-response-time-onstop 42   5H